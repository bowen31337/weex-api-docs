<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="WEEX Futures Trading API Documentation - Comprehensive endpoints for cryptocurrency derivatives trading">
    <meta name="keywords" content="WEEX, API, Futures, Trading, Cryptocurrency, Documentation">
    <title>WEEX Futures Trading API Documentation</title>
    <link rel="stylesheet" href="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui.css" />
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="https://www.weex.com/favicon.ico">
    <!-- Import CryptoJS for HMAC SHA256 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>
    <div class="bg-blob bg-blob-1"></div>
    <div class="bg-blob bg-blob-2"></div>
    <a href="#swagger-ui" class="skip-link">Skip to API Documentation</a>
    
    <header class="weex-header">
        <a href="#" class="weex-logo">
            <span>WEEX</span> API Docs
        </a>
        <button class="mobile-menu-toggle" aria-label="Toggle navigation menu" aria-expanded="false">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M3 12h18M3 6h18M3 18h18"/>
            </svg>
        </button>
        <nav class="header-links" aria-label="Main navigation">
            <a href="https://www.weex.com" target="_blank" rel="noopener noreferrer">WEEX Official</a>
            <a href="https://www.weex.com/help" target="_blank" rel="noopener noreferrer">Support Center</a>
            <a href="./CHANGELOG.md" target="_blank">Changelog</a>
            <a href="./openapi.json" download="weex-openapi.json">Download JSON</a>
            <button id="toggle-websocket" class="websocket-toggle-btn" onclick="toggleWebSocketDocs()">üîå WebSocket API</button>
        </nav>
    </header>

    <!-- Quick Info Banner -->
    <div class="info-banner">
        <div class="badge">
            <svg class="badge-icon" viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
            API Version 2.0
        </div>
        <div class="badge">
            <svg class="badge-icon" viewBox="0 0 24 24"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"/></svg>
            HMAC-SHA256 Auth
        </div>
        <div class="auth-info">
            <strong>üîê How to Use:</strong> 
            Click "Authorize" ‚Üí Enter API Key, Secret, Passphrase ‚Üí Timestamp auto-filled ‚Üí Signatures calculated by proxy
        </div>
    </div>

    <main id="swagger-ui" role="main"></main>

    <!-- WebSocket Documentation Section -->
    <section id="websocket-docs" class="websocket-section" style="display: none;">
        <div class="websocket-container">
            <h1 class="websocket-title">üîå WebSocket API Documentation</h1>
            <p class="websocket-intro">Real-time market data and account updates via WebSocket connections</p>
            
            <div class="websocket-content">
                <!-- Servers -->
                <div class="websocket-card">
                    <h2>üì° WebSocket Endpoints</h2>
                    <div class="endpoint-list">
                        <div class="endpoint-item">
                            <div class="endpoint-badge public">Public</div>
                            <code class="endpoint-url">wss://ws-contract.weex.com/v2/ws/public</code>
                            <p class="endpoint-desc">Market data (no authentication required)</p>
                        </div>
                        <div class="endpoint-item">
                            <div class="endpoint-badge private">Private</div>
                            <code class="endpoint-url">wss://ws-contract.weex.com/v2/ws/private</code>
                            <p class="endpoint-desc">Account data (authentication required)</p>
                        </div>
                    </div>
                </div>

                <!-- Connection Limits -->
                <div class="websocket-card">
                    <h2>‚öôÔ∏è Connection Limits</h2>
                    <ul class="limit-list">
                        <li><strong>Connections per IP:</strong> 300 requests per 5 minutes, max 100 concurrent</li>
                        <li><strong>Subscriptions per connection:</strong> 240 operations per hour, max 100 channels</li>
                    </ul>
                </div>

                <!-- Heartbeat -->
                <div class="websocket-card">
                    <h2>üíì Heartbeat</h2>
                    <p>Server sends ping messages periodically. Client must respond with pong to maintain connection.</p>
                    <div class="code-example">
                        <div class="code-block">
                            <h4>Ping Message:</h4>
                            <pre><code>{
  "event": "ping",
  "time": "1693208170000"
}</code></pre>
                        </div>
                        <div class="code-block">
                            <h4>Pong Response:</h4>
                            <pre><code>{
  "event": "pong",
  "time": "1693208170000"
}</code></pre>
                        </div>
                    </div>
                    <p class="note">‚ö†Ô∏è Maximum 5 missed pongs before connection is closed.</p>
                </div>

                <!-- Authentication -->
                <div class="websocket-card">
                    <h2>üîê Authentication (Private Channels)</h2>
                    <p>Private channels require header authentication:</p>
                    <table class="auth-table">
                        <thead>
                            <tr>
                                <th>Header</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>ACCESS-KEY</code></td>
                                <td>Your API key</td>
                            </tr>
                            <tr>
                                <td><code>ACCESS-PASSPHRASE</code></td>
                                <td>Your API passphrase</td>
                            </tr>
                            <tr>
                                <td><code>ACCESS-TIMESTAMP</code></td>
                                <td>Unix millisecond timestamp</td>
                            </tr>
                            <tr>
                                <td><code>ACCESS-SIGN</code></td>
                                <td>Base64(HMAC-SHA256(secret, timestamp + '/v2/ws/private'))</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <!-- Public Channels -->
                <div class="websocket-card">
                    <h2>üìä Public Channels</h2>
                    <div id="public-channels-list"></div>
                </div>

                <!-- Private Channels -->
                <div class="websocket-card">
                    <h2>üîí Private Channels</h2>
                    <div id="private-channels-list"></div>
                </div>

                <!-- Message Formats -->
                <div class="websocket-card">
                    <h2>üì® Message Formats</h2>
                    <div id="message-formats-list"></div>
                </div>

                <!-- Code Examples -->
                <div class="websocket-card">
                    <h2>üíª Code Examples</h2>
                    <div class="code-tabs">
                        <button class="code-tab active" data-tab="javascript">JavaScript</button>
                        <button class="code-tab" data-tab="python">Python</button>
                    </div>
                    <div class="code-content">
                        <div class="code-panel active" id="javascript-example">
                            <pre><code>// JavaScript WebSocket Example
const ws = new WebSocket('wss://ws-contract.weex.com/v2/ws/public');

ws.onopen = () => {
  console.log('WebSocket connected');
  
  // Subscribe to ticker channel
  ws.send(JSON.stringify({
    event: 'subscribe',
    channel: 'ticker.cmt_btcusdt'
  }));
};

ws.onmessage = (event) => {
  const message = JSON.parse(event.data);
  
  if (message.event === 'ping') {
    // Respond to heartbeat
    ws.send(JSON.stringify({
      event: 'pong',
      time: message.time
    }));
  } else if (message.event === 'payload') {
    // Handle market data
    console.log('Received data:', message.data);
  }
};

ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};

ws.onclose = () => {
  console.log('WebSocket disconnected');
};</code></pre>
                        </div>
                        <div class="code-panel" id="python-example">
                            <pre><code># Python WebSocket Example
import asyncio
import websockets
import json

async def connect_websocket():
    uri = "wss://ws-contract.weex.com/v2/ws/public"
    
    async with websockets.connect(uri) as websocket:
        # Subscribe to ticker channel
        subscribe_msg = {
            "event": "subscribe",
            "channel": "ticker.cmt_btcusdt"
        }
        await websocket.send(json.dumps(subscribe_msg))
        
        # Listen for messages
        async for message in websocket:
            data = json.loads(message)
            
            if data.get("event") == "ping":
                # Respond to heartbeat
                pong_msg = {
                    "event": "pong",
                    "time": data["time"]
                }
                await websocket.send(json.dumps(pong_msg))
            elif data.get("event") == "payload":
                # Handle market data
                print("Received data:", data["data"])

# Run the client
asyncio.run(connect_websocket())</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <footer class="api-footer">
        <p>¬© 2024 WEEX. All rights reserved. | 
            <a href="https://www.weex.com/terms" target="_blank" rel="noopener noreferrer">Terms of Service</a> | 
            <a href="https://www.weex.com/privacy" target="_blank" rel="noopener noreferrer">Privacy Policy</a>
        </p>
        <p>Base URL: <code id="base-url">https://api-contract.weex.com</code> <button onclick="copyToClipboard('https://api-contract.weex.com')" class="copy-btn-mini" aria-label="Copy Base URL">Copy</button></p>
    </footer>

    <script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js" crossorigin></script>
    <script src="https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-standalone-preset.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle({
                url: './weex-api-spec.yaml',
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout",
                
                // Enhanced configuration
                docExpansion: 'none',           // Collapse all by default
                defaultModelsExpandDepth: 2,    // Show model details
                defaultModelExpandDepth: 2,     // Expand nested models
                displayRequestDuration: true,   // Show request timing
                filter: true,                   // Enable search filter
                showExtensions: true,           // Show vendor extensions
                showCommonExtensions: true,     // Show common extensions
                tryItOutEnabled: false,         // Disable try-it-out by default (user can enable)
                persistAuthorization: true,     // Remember auth between page loads
                validatorUrl: null,             // Disable the remote validator badge
                
                // Syntax highlighting
                syntaxHighlight: {
                    activate: true,
                    theme: 'agate'
                },
                
                // Request interceptor for signature generation
                requestInterceptor: (request) => {
                    // Check if the request is destined for the WEEX API
                    if (request.url.includes('weex.com') || request.url.includes('api-contract')) {
                        const urlObj = new URL(request.url);
                        const path = urlObj.pathname;
                        
                        // Public market endpoints that don't require authentication
                        const publicEndpoints = [
                            '/capi/v2/market/time',
                            '/capi/v2/market/contracts',
                            '/capi/v2/market/depth',
                            '/capi/v2/market/tickers',
                            '/capi/v2/market/ticker',
                            '/capi/v2/market/trades',
                            '/capi/v2/market/candles',
                            '/capi/v2/market/index',
                            '/capi/v2/market/open_interest',
                            '/capi/v2/market/funding_time',
                            '/capi/v2/market/getHistoryFundRate',
                            '/capi/v2/market/currentFundRate'
                        ];
                        
                        const isPublicEndpoint = publicEndpoints.some(endpoint => path.includes(endpoint));
                        
                        // Only add auth headers for non-public endpoints
                        if (!isPublicEndpoint) {
                            const timestamp = Date.now().toString();
                            request.headers['ACCESS-TIMESTAMP'] = timestamp;
                            
                            // Ensure Content-Type is set
                            if (!request.headers['Content-Type']) {
                                request.headers['Content-Type'] = 'application/json';
                            }
                            
                            // Default locale
                            if (!request.headers['locale']) {
                                request.headers['locale'] = 'en-US';
                            }

                            // Signature Generation Logic
                            if (request.headers['ACCESS-SIGN']) {
                                try {
                                    const secretKey = request.headers['ACCESS-SIGN'];
                                    const method = request.method.toUpperCase();
                                    const body = request.body || '';
                                    
                                    // Build message: timestamp + method + path + body
                                    const message = timestamp + method + path + body;
                                    
                                    // Generate HMAC-SHA256 signature
                                    const signature = CryptoJS.HmacSHA256(message, secretKey).toString(CryptoJS.enc.Base64);
                                    
                                    request.headers['ACCESS-SIGN'] = signature;
                                    
                                    console.log('‚úÖ WEEX API Request Signed:', {
                                        timestamp: timestamp,
                                        method: method,
                                        path: path,
                                        bodyLength: body.length,
                                        signaturePreview: signature.substring(0, 20) + '...'
                                    });
                                } catch (error) {
                                    console.error('‚ùå Signature generation failed:', error);
                                }
                            }
                        } else {
                            console.log('üìä Public Market API (no auth required):', path);
                        }
                    }
                    return request;
                },
                
                // Response interceptor for debugging
                responseInterceptor: (response) => {
                    // Log response for debugging
                    if (response.url && (response.url.includes('weex.com') || response.url.includes('api-contract'))) {
                        console.log('üì• WEEX API Response:', {
                            url: response.url,
                            status: response.status,
                            duration: response.duration + 'ms'
                        });
                    }
                    return response;
                },
                
                // Custom operation sorting
                operationsSorter: (a, b) => {
                    const methodOrder = ['get', 'post', 'put', 'patch', 'delete'];
                    return methodOrder.indexOf(a.get('method')) - methodOrder.indexOf(b.get('method'));
                },
                
                // Custom tag sorting (keep original order)
                tagsSorter: 'alpha'
            });
            
            // Add keyboard shortcut for search
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                    e.preventDefault();
                    const filterInput = document.querySelector('.operation-filter-input');
                    if (filterInput) {
                        filterInput.focus();
                    }
                }
            });
            
            // Auto-populate timestamp when Authorize dialog opens
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1 && node.classList && node.classList.contains('dialog-ux')) {
                            // Find the ACCESS-TIMESTAMP input field
                            setTimeout(() => {
                                const timestampInput = document.querySelector('input[name="ACCESS-TIMESTAMP"]');
                                if (timestampInput && !timestampInput.value) {
                                    timestampInput.value = Date.now().toString();
                                    // Trigger input event to update Swagger UI state
                                    timestampInput.dispatchEvent(new Event('input', { bubbles: true }));
                                    console.log('üïê Auto-populated ACCESS-TIMESTAMP:', timestampInput.value);
                                }
                            }, 100);
                        }
                    });
                });
            });
            
            observer.observe(document.body, { childList: true, subtree: true });
            
            // Refresh timestamp every 30 seconds if dialog is open
            setInterval(() => {
                const timestampInput = document.querySelector('input[name="ACCESS-TIMESTAMP"]');
                if (timestampInput) {
                    timestampInput.value = Date.now().toString();
                    timestampInput.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }, 30000);

            // Mobile menu toggle functionality
            const mobileMenuToggle = document.querySelector('.mobile-menu-toggle');
            const headerLinks = document.querySelector('.header-links');
            
            if (mobileMenuToggle && headerLinks) {
                mobileMenuToggle.addEventListener('click', () => {
                    const isExpanded = mobileMenuToggle.getAttribute('aria-expanded') === 'true';
                    mobileMenuToggle.setAttribute('aria-expanded', !isExpanded);
                    headerLinks.classList.toggle('active');
                });

                // Close menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!headerLinks.contains(e.target) && !mobileMenuToggle.contains(e.target)) {
                        headerLinks.classList.remove('active');
                        mobileMenuToggle.setAttribute('aria-expanded', 'false');
                    }
                });

                // Close menu when clicking on a link
                headerLinks.querySelectorAll('a').forEach(link => {
                    link.addEventListener('click', () => {
                        headerLinks.classList.remove('active');
                        mobileMenuToggle.setAttribute('aria-expanded', 'false');
                    });
                });
            }

            // Spotlight Effect Implementation
            document.addEventListener('mousemove', (e) => {
                const cards = document.querySelectorAll('.swagger-ui .opblock');
                cards.forEach(card => {
                    if (!card.querySelector('.spotlight')) {
                        const spotlight = document.createElement('div');
                        spotlight.className = 'spotlight';
                        card.appendChild(spotlight);
                    }
                    
                    const rect = card.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    card.style.setProperty('--x', `${x}px`);
                    card.style.setProperty('--y', `${y}px`);
                });
            });

            // Smooth Tag Expansion Animation
            const observerTags = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    mutation.addedNodes.forEach((node) => {
                        if (node.nodeType === 1 && node.classList && node.classList.contains('opblock-tag-section')) {
                            node.style.opacity = '0';
                            node.style.transform = 'translateY(10px)';
                            setTimeout(() => {
                                node.style.transition = 'all 0.5s ease-out';
                                node.style.opacity = '1';
                                node.style.transform = 'translateY(0)';
                            }, 50);
                        }
                    });
                });
            });
            
            observerTags.observe(document.body, { childList: true, subtree: true });
            
            // Load and render WebSocket documentation
            loadWebSocketDocs();
        };
        
        // Toggle between REST API and WebSocket documentation
        function toggleWebSocketDocs() {
            const swaggerUI = document.getElementById('swagger-ui');
            const websocketDocs = document.getElementById('websocket-docs');
            const toggleBtn = document.getElementById('toggle-websocket');
            
            if (websocketDocs.style.display === 'none') {
                swaggerUI.style.display = 'none';
                websocketDocs.style.display = 'block';
                toggleBtn.textContent = 'üì° REST API';
                window.scrollTo({ top: 0, behavior: 'smooth' });
            } else {
                swaggerUI.style.display = 'block';
                websocketDocs.style.display = 'none';
                toggleBtn.textContent = 'üîå WebSocket API';
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }
        
        // Load WebSocket documentation from OpenAPI spec
        async function loadWebSocketDocs() {
            try {
                const response = await fetch('./openapi.json');
                const spec = await response.json();
                const wsData = spec['x-websocket'];
                
                if (!wsData) return;
                
                // Render public channels
                renderChannels(wsData.channels.public, 'public-channels-list', 'Public');
                
                // Render private channels
                renderChannels(wsData.channels.private, 'private-channels-list', 'Private');
                
                // Render message formats
                renderMessageFormats(wsData.message_formats);
                
                // Initialize code tabs after content is loaded
                setTimeout(initCodeTabs, 100);
                
            } catch (error) {
                console.error('Failed to load WebSocket documentation:', error);
            }
        }
        
        // Render channels
        function renderChannels(channels, containerId, type) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            Object.keys(channels).forEach(channelName => {
                const channel = channels[channelName];
                const channelDiv = document.createElement('div');
                channelDiv.className = 'channel-item';
                
                let html = `<h3>${channelName.charAt(0).toUpperCase() + channelName.slice(1)}</h3>`;
                html += `<p>${channel.description}</p>`;
                
                if (channel.channel_format) {
                    html += `<div class="channel-format">${channel.channel_format}</div>`;
                }
                
                if (channel.subscribe) {
                    html += `<div class="channel-example"><h4>Subscribe:</h4><pre><code>${JSON.stringify(channel.subscribe, null, 2)}</code></pre></div>`;
                }
                
                if (channel.subscribe_response) {
                    html += `<div class="channel-example"><h4>Subscribe Response:</h4><pre><code>${JSON.stringify(channel.subscribe_response, null, 2)}</code></pre></div>`;
                }
                
                if (channel.payload) {
                    html += `<div class="channel-example"><h4>Payload Example:</h4><pre><code>${JSON.stringify(channel.payload, null, 2)}</code></pre></div>`;
                }
                
                if (channel.fields) {
                    html += '<div class="channel-example"><h4>Fields:</h4><ul>';
                    Object.keys(channel.fields).forEach(field => {
                        html += `<li><strong>${field}:</strong> ${channel.fields[field]}</li>`;
                    });
                    html += '</ul></div>';
                }
                
                if (channel.levels) {
                    html += `<div class="channel-example"><h4>Available Levels:</h4><p>${channel.levels.join(', ')}</p></div>`;
                }
                
                if (channel.price_types) {
                    html += `<div class="channel-example"><h4>Price Types:</h4><p>${channel.price_types.join(', ')}</p></div>`;
                }
                
                if (channel.intervals) {
                    html += `<div class="channel-example"><h4>Intervals:</h4><p>${channel.intervals.join(', ')}</p></div>`;
                }
                
                channelDiv.innerHTML = html;
                container.appendChild(channelDiv);
            });
        }
        
        // Render message formats
        function renderMessageFormats(formats) {
            const container = document.getElementById('message-formats-list');
            if (!container) return;
            
            Object.keys(formats).forEach(formatName => {
                const format = formats[formatName];
                const formatDiv = document.createElement('div');
                formatDiv.className = 'channel-item';
                
                let html = `<h3>${formatName.charAt(0).toUpperCase() + formatName.slice(1)}</h3>`;
                html += `<div class="channel-example"><pre><code>${JSON.stringify(format, null, 2)}</code></pre></div>`;
                
                formatDiv.innerHTML = html;
                container.appendChild(formatDiv);
            });
        }
        
        // Code tab switching
        function initCodeTabs() {
            const codeTabs = document.querySelectorAll('.code-tab');
            codeTabs.forEach(tab => {
                // Remove existing listeners to avoid duplicates
                const newTab = tab.cloneNode(true);
                tab.parentNode.replaceChild(newTab, tab);
                
                newTab.addEventListener('click', () => {
                    const tabName = newTab.dataset.tab;
                    const codeCard = newTab.closest('.websocket-card');
                    const codeContent = codeCard.querySelector('.code-content');
                    
                    // Update active tab within this card
                    const cardTabs = codeCard.querySelectorAll('.code-tab');
                    cardTabs.forEach(t => t.classList.remove('active'));
                    newTab.classList.add('active');
                    
                    // Update active panel
                    const panels = codeContent.querySelectorAll('.code-panel');
                    panels.forEach(panel => {
                        panel.classList.remove('active');
                        if (panel.id === `${tabName}-example`) {
                            panel.classList.add('active');
                        }
                    });
                });
            });
        }

        // Utility: Copy to Clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                const toast = document.createElement('div');
                toast.innerText = 'Copied to clipboard!';
                toast.className = 'toast-notification';
                document.body.appendChild(toast);
                setTimeout(() => {
                    toast.classList.add('fade-out');
                    setTimeout(() => toast.remove(), 300);
                }, 2000);
            });
        }
    </script>
</body>
</html>
